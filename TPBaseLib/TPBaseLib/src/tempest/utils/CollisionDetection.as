package tempest.utils{	import flash.display.BitmapData;	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.geom.Matrix;	import flash.geom.ColorTransform;	import flash.geom.Rectangle;	/**	 * 不规则物体碰撞	 */	public class CollisionDetection	{		/**		 * 碰撞检测		 * @param p_obj1 检测对象		 * @param p_obj2 检测对象		 * @param p_alphaTolerance 碰撞允许的透明度 0-255的数值  较大的数值允许更多透明部分碰撞 默认为255		 * @return 返回两个图形相交的矩形  不相交返回空		 */		public static function checkForCollision(p_obj1:DisplayObject, p_obj2:DisplayObject, p_alphaTolerance:Number = 255):Rectangle		{			// 取得元件在其容器内的矩形			var bounds1:Object = p_obj1.getBounds(p_obj1.root);			var bounds2:Object = p_obj2.getBounds(p_obj2.root);			// 判断是否有重叠部分 没有返回NULL			if (((bounds1.right < bounds2.left) || (bounds2.right < bounds1.left)) || ((bounds1.bottom < bounds2.top) || (bounds2.bottom < bounds1.top)))			{				return null;			}			// 计算两个矩形相交部分			var bounds:Object = {};			bounds.left = Math.max(bounds1.left, bounds2.left);			bounds.right = Math.min(bounds1.right, bounds2.right);			bounds.top = Math.max(bounds1.top, bounds2.top);			bounds.bottom = Math.min(bounds1.bottom, bounds2.bottom);			// 计算相交部分的宽和高			var w:Number = bounds.right - bounds.left;			var h:Number = bounds.bottom - bounds.top;			// 像素小于1的BitmapData是无效的  判断为未碰撞			if (w < 1 || h < 1)				return null;			// 生成相交区域大小的 BitmapData			var bitmapData:BitmapData = new BitmapData(w, h, false);			// 1层图像对象			var matrix:Matrix = p_obj1.transform.concatenatedMatrix;			matrix.tx -= bounds.left; // x方向平行移动			matrix.ty -= bounds.top; // y方向平行移动			bitmapData.draw(p_obj1, matrix, new ColorTransform(1, 1, 1, 1, 255, -255, -255, p_alphaTolerance));			// 2层图形对象			matrix = p_obj2.transform.concatenatedMatrix;			matrix.tx -= bounds.left; // x方向平行移动			matrix.ty -= bounds.top; // y方向平行移动			bitmapData.draw(p_obj2, matrix, new ColorTransform(1, 1, 1, 1, 255, 255, 255, p_alphaTolerance), BlendMode.DIFFERENCE);			// 取得完全重叠部分区域（0xFF00FFFF）			var intersection:Rectangle = bitmapData.getColorBoundsRect(0xFFFFFFFF, 0xFF00FFFF);			// 如果不完全重叠 返回NULL			if (intersection.width == 0)				return null;			// 位置调整			intersection.x += bounds.left;			intersection.y += bounds.top;			return intersection;		}	}}