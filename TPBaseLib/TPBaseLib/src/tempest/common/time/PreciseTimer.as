package tempest.common.time{	import flash.display.Shape;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.TimerEvent;	import flash.utils.Dictionary;	import tempest.common.logging.*;	/**	 * 精确计时器类 比默认计时器精确   不能作为局部变量使用 否则在函数执行完成时会被回收	 */	public class PreciseTimer extends EventDispatcher	{		private static const log:ILogger = TLog.getLogger(PreciseTimer);		private var _delay:Number;		private var _repeatCount:int;		private var _currentCount:int;		private var _offset:int;		private static var _currentTime:Number;		private var _running:Boolean = false;		private static var driver:Shape;		private static var ticks:Dictionary = new Dictionary(true);		/**		 *		 * @param delay 延迟		 * @param repeatCount 重复次数		 */		public function PreciseTimer(delay:Number = 1000, repeatCount:int = 0)		{			this.delay = delay;			this.repeatCount = repeatCount;			reset();		}		staticInit();		private static function staticInit():void		{			(driver = new Shape()).addEventListener(Event.ENTER_FRAME, onStaticTick);			_currentTime = new Date().time;		}		private static function onStaticTick(e:Event):void		{			var now:Number = new Date().time;			var msDiff:int = now - _currentTime;			_currentTime = now;			var pt:Object;			for (pt in ticks)			{				pt.onTick(msDiff);			}		}		/**		 * 开始计时器		 */		public function start():void		{			if (_running)				return;			_running = true;			ticks[this] = true;		}		/**		 * 停止计时器		 */		public function stop():void		{			if (!_running)				return;			_running = false;			delete ticks[this];		}		/**		 * 重置计时器		 */		public function reset():void		{			stop();			_currentCount = _offset = 0;		}		override public function toString():String		{			return "[PreciseTimer, currentCount=" + _currentCount + "]";		}		/**		 * 获取延迟间隔		 */		public function get delay():Number		{			return _delay;		}		/**		 * 设置延迟间隔		 * @param v		 * @throws IllegalArgumentException		 */		public function set delay(v:Number):void		{			if (v < 0 || v == Number.POSITIVE_INFINITY)			{				log.error(" The specified delay is negative or not a finite number.");				return;			}			if (_delay != v)			{				_delay = v;				_currentCount = _offset = 0;			}		}		/**		 * 获取重复次数		 */		public function get repeatCount():int		{			return _repeatCount;		}		/**		 * 设置重复次数		 * @param v		 */		public function set repeatCount(v:int):void		{			_repeatCount = v;		}		/**		 * 获取当前次数		 */		public function get currentCount():int		{			return _currentCount;		}		/**		 * 计时器是否正在执行		 */		public function get running():Boolean		{			return _running;		}		/**		 * @private		 */		private function onTick(diff:int):void		{			_offset += diff;			if (_offset > _delay)			{				while (_offset > _delay)				{					_currentCount++;					_offset -= _delay;					if (_repeatCount != 0)					{						if (_currentCount == _repeatCount)						{							dispatchEvent(new TimerEvent(TimerEvent.TIMER));							dispatchEvent(new TimerEvent(TimerEvent.TIMER_COMPLETE));							stop();						}						else if (_currentCount < _repeatCount)						{							dispatchEvent(new TimerEvent(TimerEvent.TIMER));						}					}					else					{						dispatchEvent(new TimerEvent(TimerEvent.TIMER));					}					if (_delay <= 0)					{						break;					}				}			}		}	}}